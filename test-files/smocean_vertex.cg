struct smoutput {
  float4 position : POSITION;
  float4 color : COLOR;
//  float3 normal : NORMAL;
};

// geowave*[0] = phase
// geowave*[1] = amp
// geowave*[2] = freq
// geowave*[3] = fade

void main(float4 position : POSITION, out smoutput OUT,
          uniform float4 geowave1,
          uniform float4 geowave2,
          uniform float4 geowave3,
          uniform float4 geowave4,
          uniform float2 geowave1dir,
          uniform float2 geowave2dir,
          uniform float2 geowave3dir,
          uniform float2 geowave4dir,
          uniform float4 geowaveQ)
{
  float4x4 modelViewProj = glstate.matrix.mvp ;
  
  float4 p = position;
  float sinval1, cosval1;
  float sinval2, cosval2;
  float sinval3, cosval3;
  float sinval4, cosval4;
  float2 xy;
  xy[0] = p[0];
  xy[1] = p[1];

  float dot1 = dot(xy, geowave1dir);
  float dot2 = dot(xy, geowave2dir);
  float dot3 = dot(xy, geowave3dir);
  float dot4 = dot(xy, geowave4dir);

  sincos(dot1 * geowave1[2] + geowave1[0], sinval1, cosval1); 
  sincos(dot2 * geowave2[2] + geowave2[0], sinval2, cosval2); 
  sincos(dot3 * geowave3[2] + geowave3[0], sinval3, cosval3); 
  sincos(dot4 * geowave4[2] + geowave4[0], sinval4, cosval4); 

  // tv[0] += Q[i]*this->geowaves[i].amp*this->geowaves[i].dir[0] * cosval;

         //+ 
         //geowaveQ[0] * geowave1[1]*geowave1dir[0]*cosval1 + 
         //geowaveQ[1] * geowave2[1]*geowave2dir[0]*cosval2 + 
         //geowaveQ[2] * geowave3[1]*geowave3dir[0]*cosval3 + 
         //geowaveQ[3] * geowave4[1]*geowave4dir[0]*cosval4; 

         //+ 
         //geowaveQ[0] * geowave1[1]*geowave1dir[1]*cosval1 + 
         //geowaveQ[1] * geowave2[1]*geowave2dir[1]*cosval2 + 
         //geowaveQ[2] * geowave3[1]*geowave3dir[1]*cosval3 + 
         //geowaveQ[3] * geowave4[1]*geowave4dir[1]*cosval4; 

  p[2] = geowave1[1] * sinval1 + 
         geowave2[1] * sinval2 + 
         geowave3[1] * sinval3 + 
         geowave4[1] * sinval4; 
  p[3] = 1.0;

  OUT.position = mul(modelViewProj, p);    // position in clip space
  OUT.color = float4(1,1,1,1);
}


//  for (i = 0; i < NUM_GEO_WAVES; i++) {
//    float dot = this->geowaves[i].dir[0] * tv[0] + this->geowaves[i].dir[1] * tv[1];
//    float cossinval = (float) (dot *
//                               this->geowaves[i].freq + 
//                               this->geowaves[i].phase);
//    float cosval = (float) cos(cossinval);
//    float sinval = (float) sin(cossinval);

//    tn[0] -= (this->geowaves[i].freq * 
//              this->geowaves[i].amp *
//              cosval);
 //   tn[1] -= (this->geowaves[i].freq * 
 //             this->geowaves[i].amp *
//              cosval);
//    tn[2] -= Q[i] * this->geowaves[i].freq * this->geowaves[i].amp * sinval;
//  }

//  for (i = 0; i < NUM_GEO_WAVES; i++) {

//    float dot = this->geowaves[i].dir[0] * in[0] + this->geowaves[i].dir[1] * in[1];
//    float cossinval = (float) (dot *
 //                              this->geowaves[i].freq + 
 //                              this->geowaves[i].phase);
    
 //   float cosval = (float) cos(cossinval);
 //   float sinval = (float) sin(cossinval);

 //   tv[0] += Q[i]*this->geowaves[i].amp*this->geowaves[i].dir[0] * cosval;
 //   tv[1] += Q[i]*this->geowaves[i].amp*this->geowaves[i].dir[1] * cosval;
 //   tv[2] += this->geowaves[i].amp * sinval;
 // }

