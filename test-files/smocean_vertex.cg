struct smoutput {
  float4 position : POSITION;
  float4 color : COLOR;
//  float3 normal : NORMAL;
};

// geowave*[0] = phase
// geowave*[1] = amp
// geowave*[2] = freq
// geowave*[3] = fade

void main(float4 position : POSITION, out smoutput OUT,
          uniform float4 geowaveAmp,
          uniform float4 geowaveFreq,
          uniform float4 geowavePhase,
          uniform float2 geowave1dir,
          uniform float2 geowave2dir,
          uniform float2 geowave3dir,
          uniform float2 geowave4dir,
          uniform float4 geowaveQ)
{
  float4x4 modelViewProj = glstate.matrix.mvp ;
  
  float4 p;
  float sinval1, cosval1;
  float sinval2, cosval2;
  float sinval3, cosval3;
  float sinval4, cosval4;
  float2 xy;
  xy[0] = position[0];
  xy[1] = position[1];

  float dot1 = dot(xy, geowave1dir);
  float dot2 = dot(xy, geowave2dir);
  float dot3 = dot(xy, geowave3dir);
  float dot4 = dot(xy, geowave4dir);

  sincos(dot1 * geowaveFreq[0] + geowavePhase[0], sinval1, cosval1); 
  sincos(dot2 * geowaveFreq[1] + geowavePhase[1], sinval2, cosval2); 
  sincos(dot3 * geowaveFreq[2] + geowavePhase[2], sinval3, cosval3); 
  sincos(dot4 * geowaveFreq[3] + geowavePhase[3], sinval4, cosval4); 

  float4 sinvec = float4(sinval1, sinval2, sinval3, sinval4);
  //  float4 cosvec = float4(cosval1, cosval2, cosval3, cosval4);

  p[0] = position[0] + 
         geowaveQ[0] * geowaveAmp[0] * geowave1dir[0] * cosval1 + 
         geowaveQ[1] * geowaveAmp[1] * geowave2dir[0] * cosval2 + 
         geowaveQ[2] * geowaveAmp[2] * geowave3dir[0] * cosval3 + 
         geowaveQ[3] * geowaveAmp[3] * geowave4dir[0] * cosval4; 

  p[1] = position[1] + 
         geowaveQ[0] * geowaveAmp[0] * geowave1dir[1] * cosval1 + 
         geowaveQ[1] * geowaveAmp[1] * geowave2dir[1] * cosval2 + 
         geowaveQ[2] * geowaveAmp[2] * geowave3dir[1] * cosval3 + 
         geowaveQ[3] * geowaveAmp[3] * geowave4dir[1] * cosval4; 

  p[2] = dot(geowaveAmp, sinvec);
  p[3] = 1.0;

  OUT.position = mul(modelViewProj, p);    // position in clip space
  OUT.color = float4(1,1,1,1);
}


//  for (i = 0; i < NUM_GEO_WAVES; i++) {
//    float dot = this->geowaves[i].dir[0] * tv[0] + this->geowaves[i].dir[1] * tv[1];
//    float cossinval = (float) (dot *
//                               this->geowaves[i].freq + 
//                               this->geowaves[i].phase);
//    float cosval = (float) cos(cossinval);
//    float sinval = (float) sin(cossinval);

//    tn[0] -= (this->geowaves[i].freq * 
//              this->geowaves[i].amp *
//              cosval);
 //   tn[1] -= (this->geowaves[i].freq * 
 //             this->geowaves[i].amp *
//              cosval);
//    tn[2] -= Q[i] * this->geowaves[i].freq * this->geowaves[i].amp * sinval;
//  }

//  for (i = 0; i < NUM_GEO_WAVES; i++) {

//    float dot = this->geowaves[i].dir[0] * in[0] + this->geowaves[i].dir[1] * in[1];
//    float cossinval = (float) (dot *
 //                              this->geowaves[i].freq + 
 //                              this->geowaves[i].phase);
    
 //   float cosval = (float) cos(cossinval);
 //   float sinval = (float) sin(cossinval);

 //   tv[0] += Q[i]*this->geowaves[i].amp*this->geowaves[i].dir[0] * cosval;
 //   tv[1] += Q[i]*this->geowaves[i].amp*this->geowaves[i].dir[1] * cosval;
 //   tv[2] += this->geowaves[i].amp * sinval;
 // }

